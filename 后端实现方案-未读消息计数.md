# 班次交接未读消息计数功能 - 后端实现方案

## 一、数据库表设计

### 1. 任务沟通记录表（task_comment）

```sql
CREATE TABLE `task_comment` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `task_id` BIGINT NOT NULL COMMENT '任务ID',
  `user_id` VARCHAR(50) NOT NULL COMMENT '发送者用户ID（工号）',
  `user_name` VARCHAR(100) NOT NULL COMMENT '发送者姓名',
  `user_role` VARCHAR(20) NOT NULL COMMENT '用户角色：handoverFrom-发布者, handoverTo-被交接者',
  `content` TEXT NOT NULL COMMENT '消息内容',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` DATETIME DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务沟通记录表';
```

### 2. 消息已读记录表（comment_read_record）

```sql
CREATE TABLE `comment_read_record` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` VARCHAR(50) NOT NULL COMMENT '用户ID（工号）',
  `task_id` BIGINT NOT NULL COMMENT '任务ID',
  `comment_id` BIGINT NOT NULL COMMENT '消息ID',
  `read_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '已读时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_task_comment` (`user_id`, `task_id`, `comment_id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_comment_id` (`comment_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='消息已读记录表';
```

## 二、实体类（Entity）

### 1. TaskComment.java

```java
package com.example.shifthandover.entity;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class TaskComment {
    private Long id;
    private Long taskId;
    private String userId;
    private String userName;
    private String userRole; // handoverFrom, handoverTo
    private String content;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    // 前端需要的字段
    private Boolean isRead; // 当前用户是否已读
}
```

### 2. CommentReadRecord.java

```java
package com.example.shifthandover.entity;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class CommentReadRecord {
    private Long id;
    private String userId;
    private Long taskId;
    private Long commentId;
    private LocalDateTime readTime;
}
```

## 三、Mapper接口（MyBatis）

### 1. TaskCommentMapper.java

```java
package com.example.shifthandover.mapper;

import com.example.shifthandover.entity.TaskComment;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import java.util.List;

@Mapper
public interface TaskCommentMapper {
    
    /**
     * 插入沟通记录
     */
    int insert(TaskComment comment);
    
    /**
     * 根据任务ID查询沟通记录列表
     */
    List<TaskComment> selectByTaskId(@Param("taskId") Long taskId);
    
    /**
     * 根据任务ID和用户ID查询未读消息数量
     */
    int countUnreadByTaskIdAndUserId(@Param("taskId") Long taskId, @Param("userId") String userId);
    
    /**
     * 查询用户在所有任务中的未读消息数量汇总
     * 返回 Map<taskId, unreadCount>
     */
    List<UnreadCountVO> selectUnreadCountsByUserId(@Param("userId") String userId);
}
```

### 2. CommentReadRecordMapper.java

```java
package com.example.shifthandover.mapper;

import com.example.shifthandover.entity.CommentReadRecord;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import java.util.List;

@Mapper
public interface CommentReadRecordMapper {
    
    /**
     * 插入已读记录
     */
    int insert(CommentReadRecord record);
    
    /**
     * 批量插入已读记录
     */
    int insertBatch(@Param("records") List<CommentReadRecord> records);
    
    /**
     * 查询用户是否已读某条消息
     */
    boolean existsByUserIdAndCommentId(@Param("userId") String userId, @Param("commentId") Long commentId);
    
    /**
     * 查询用户在某个任务中已读的所有消息ID
     */
    List<Long> selectReadCommentIds(@Param("userId") String userId, @Param("taskId") Long taskId);
}
```

## 四、MyBatis XML映射文件

### 1. TaskCommentMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.shifthandover.mapper.TaskCommentMapper">

    <resultMap id="BaseResultMap" type="com.example.shifthandover.entity.TaskComment">
        <id column="id" property="id"/>
        <result column="task_id" property="taskId"/>
        <result column="user_id" property="userId"/>
        <result column="user_name" property="userName"/>
        <result column="user_role" property="userRole"/>
        <result column="content" property="content"/>
        <result column="create_time" property="createTime"/>
        <result column="update_time" property="updateTime"/>
    </resultMap>

    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO task_comment (task_id, user_id, user_name, user_role, content, create_time)
        VALUES (#{taskId}, #{userId}, #{userName}, #{userRole}, #{content}, NOW())
    </insert>

    <select id="selectByTaskId" resultMap="BaseResultMap">
        SELECT * FROM task_comment
        WHERE task_id = #{taskId}
        ORDER BY create_time ASC
    </select>

    <select id="countUnreadByTaskIdAndUserId" resultType="int">
        SELECT COUNT(1)
        FROM task_comment tc
        WHERE tc.task_id = #{taskId}
          AND tc.user_id != #{userId}
          AND NOT EXISTS (
              SELECT 1 FROM comment_read_record crr
              WHERE crr.user_id = #{userId}
                AND crr.task_id = #{taskId}
                AND crr.comment_id = tc.id
          )
    </select>

    <select id="selectUnreadCountsByUserId" resultType="com.example.shifthandover.vo.UnreadCountVO">
        SELECT 
            tc.task_id AS taskId,
            COUNT(1) AS unreadCount
        FROM task_comment tc
        WHERE tc.user_id != #{userId}
          AND NOT EXISTS (
              SELECT 1 FROM comment_read_record crr
              WHERE crr.user_id = #{userId}
                AND crr.task_id = tc.task_id
                AND crr.comment_id = tc.id
          )
        GROUP BY tc.task_id
        HAVING unreadCount > 0
    </select>

</mapper>
```

### 2. CommentReadRecordMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.shifthandover.mapper.CommentReadRecordMapper">

    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO comment_read_record (user_id, task_id, comment_id, read_time)
        VALUES (#{userId}, #{taskId}, #{commentId}, NOW())
        ON DUPLICATE KEY UPDATE read_time = NOW()
    </insert>

    <insert id="insertBatch">
        INSERT INTO comment_read_record (user_id, task_id, comment_id, read_time)
        VALUES
        <foreach collection="records" item="record" separator=",">
            (#{record.userId}, #{record.taskId}, #{record.commentId}, NOW())
        </foreach>
        ON DUPLICATE KEY UPDATE read_time = NOW()
    </insert>

    <select id="existsByUserIdAndCommentId" resultType="boolean">
        SELECT COUNT(1) > 0
        FROM comment_read_record
        WHERE user_id = #{userId} AND comment_id = #{commentId}
    </select>

    <select id="selectReadCommentIds" resultType="long">
        SELECT comment_id
        FROM comment_read_record
        WHERE user_id = #{userId} AND task_id = #{taskId}
    </select>

</mapper>
```

## 五、Service层

### TaskCommentService.java

```java
package com.example.shifthandover.service;

import com.example.shifthandover.entity.TaskComment;
import com.example.shifthandover.entity.CommentReadRecord;
import com.example.shifthandover.mapper.TaskCommentMapper;
import com.example.shifthandover.mapper.CommentReadRecordMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TaskCommentService {
    
    private final TaskCommentMapper taskCommentMapper;
    private final CommentReadRecordMapper readRecordMapper;
    
    /**
     * 添加沟通记录
     */
    @Transactional
    public TaskComment addComment(Long taskId, String userId, String userName, 
                                   String userRole, String content) {
        TaskComment comment = new TaskComment();
        comment.setTaskId(taskId);
        comment.setUserId(userId);
        comment.setUserName(userName);
        comment.setUserRole(userRole);
        comment.setContent(content);
        
        taskCommentMapper.insert(comment);
        return comment;
    }
    
    /**
     * 获取任务的沟通记录列表（带已读状态）
     */
    public List<TaskComment> getCommentsByTaskId(Long taskId, String currentUserId) {
        List<TaskComment> comments = taskCommentMapper.selectByTaskId(taskId);
        
        // 查询当前用户已读的消息ID列表
        List<Long> readCommentIds = readRecordMapper.selectReadCommentIds(currentUserId, taskId);
        
        // 设置已读状态
        comments.forEach(comment -> {
            // 自己发的消息默认已读
            if (comment.getUserId().equals(currentUserId)) {
                comment.setIsRead(true);
            } else {
                comment.setIsRead(readCommentIds.contains(comment.getId()));
            }
        });
        
        return comments;
    }
    
    /**
     * 获取任务的未读消息数量
     */
    public Integer getUnreadCount(Long taskId, String userId) {
        return taskCommentMapper.countUnreadByTaskIdAndUserId(taskId, userId);
    }
    
    /**
     * 获取所有任务的未读消息数量汇总
     */
    public Map<Long, Integer> getAllUnreadCounts(String userId) {
        List<UnreadCountVO> unreadCounts = taskCommentMapper.selectUnreadCountsByUserId(userId);
        return unreadCounts.stream()
            .collect(Collectors.toMap(
                UnreadCountVO::getTaskId,
                UnreadCountVO::getUnreadCount
            ));
    }
    
    /**
     * 标记消息为已读
     */
    @Transactional
    public void markAsRead(Long taskId, String userId, List<Long> commentIds) {
        if (commentIds == null || commentIds.isEmpty()) {
            // 如果没有指定commentIds，标记该任务的所有未读消息为已读
            List<TaskComment> comments = taskCommentMapper.selectByTaskId(taskId);
            commentIds = comments.stream()
                .filter(c -> !c.getUserId().equals(userId)) // 排除自己发的消息
                .map(TaskComment::getId)
                .collect(Collectors.toList());
        }
        
        // 批量插入已读记录
        List<CommentReadRecord> records = commentIds.stream()
            .map(commentId -> {
                CommentReadRecord record = new CommentReadRecord();
                record.setUserId(userId);
                record.setTaskId(taskId);
                record.setCommentId(commentId);
                return record;
            })
            .collect(Collectors.toList());
        
        if (!records.isEmpty()) {
            readRecordMapper.insertBatch(records);
        }
    }
}
```

## 六、Controller层

### TaskCommentController.java

```java
package com.example.shifthandover.controller;

import com.example.shifthandover.entity.TaskComment;
import com.example.shifthandover.service.TaskCommentService;
import com.example.shifthandover.common.Result;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/shift-handover/tasks")
@RequiredArgsConstructor
public class TaskCommentController {
    
    private final TaskCommentService commentService;
    
    /**
     * 获取任务的沟通记录
     */
    @GetMapping("/{taskId}/comments")
    public Result<List<TaskComment>> getComments(
            @PathVariable Long taskId,
            @RequestHeader("X-User-Id") String userId) {
        List<TaskComment> comments = commentService.getCommentsByTaskId(taskId, userId);
        return Result.success(comments);
    }
    
    /**
     * 添加沟通记录
     */
    @PostMapping("/{taskId}/comments")
    public Result<TaskComment> addComment(
            @PathVariable Long taskId,
            @RequestBody AddCommentRequest request,
            @RequestHeader("X-User-Id") String userId,
            @RequestHeader("X-User-Name") String userName) {
        
        // 从任务信息中获取用户角色（需要调用TaskService）
        String userRole = getTaskUserRole(taskId, userId);
        
        TaskComment comment = commentService.addComment(
            taskId, userId, userName, userRole, request.getContent()
        );
        
        return Result.success(comment);
    }
    
    /**
     * 获取任务的未读消息数量
     */
    @GetMapping("/{taskId}/unread-count")
    public Result<UnreadCountResponse> getUnreadCount(
            @PathVariable Long taskId,
            @RequestHeader("X-User-Id") String userId) {
        Integer count = commentService.getUnreadCount(taskId, userId);
        return Result.success(new UnreadCountResponse(taskId, count));
    }
    
    /**
     * 获取所有任务的未读消息数量汇总
     */
    @GetMapping("/unread-counts")
    public Result<Map<Long, Integer>> getAllUnreadCounts(
            @RequestHeader("X-User-Id") String userId) {
        Map<Long, Integer> counts = commentService.getAllUnreadCounts(userId);
        return Result.success(counts);
    }
    
    /**
     * 标记消息为已读
     */
    @PutMapping("/{taskId}/comments/read")
    public Result<Void> markAsRead(
            @PathVariable Long taskId,
            @RequestBody(required = false) MarkReadRequest request,
            @RequestHeader("X-User-Id") String userId) {
        
        List<Long> commentIds = request != null ? request.getCommentIds() : null;
        commentService.markAsRead(taskId, userId, commentIds);
        return Result.success();
    }
    
    // 辅助方法：获取用户在任务中的角色
    private String getTaskUserRole(Long taskId, String userId) {
        // 需要调用TaskService获取任务信息
        // Task task = taskService.getById(taskId);
        // if (task.getHandoverFromId().equals(userId)) {
        //     return "handoverFrom";
        // } else if (task.getHandoverToId().equals(userId)) {
        //     return "handoverTo";
        // }
        // return "handoverFrom";
        return "handoverFrom"; // 简化示例
    }
}

// 请求DTO
@Data
class AddCommentRequest {
    private String content;
}

@Data
class MarkReadRequest {
    private List<Long> commentIds;
}

// 响应DTO
@Data
@AllArgsConstructor
class UnreadCountResponse {
    private Long taskId;
    private Integer unreadCount;
}
```

## 七、VO类

### UnreadCountVO.java

```java
package com.example.shifthandover.vo;

import lombok.Data;

@Data
public class UnreadCountVO {
    private Long taskId;
    private Integer unreadCount;
}
```

## 八、使用说明

### 1. 前端调用示例

```javascript
// 获取所有任务的未读数量
const res = await getAllUnreadCounts()
// 返回: { 2: 3, 3: 1 }  // 任务2有3条未读，任务3有1条未读

// 获取单个任务的未读数量
const res = await getUnreadCommentCount(taskId)
// 返回: { taskId: 2, unreadCount: 3 }

// 标记消息为已读（点击任务时调用）
await markCommentsAsRead(taskId) // 标记该任务所有未读消息为已读
// 或
await markCommentsAsRead(taskId, [1, 2, 3]) // 标记指定消息为已读
```

### 2. 性能优化建议

1. **缓存未读数量**：使用Redis缓存用户的未读数量，减少数据库查询
2. **批量查询优化**：使用LEFT JOIN一次性查询已读状态，避免N+1查询
3. **定时任务**：定期清理过期的已读记录（可选）

### 3. 实时更新方案

如果需要实时更新未读数量，可以使用：
- **WebSocket**：当有新消息时，推送给相关用户
- **轮询**：前端定时调用 `getAllUnreadCounts` 接口
- **SSE（Server-Sent Events）**：服务器主动推送更新

## 九、注意事项

1. **用户ID获取**：实际项目中应该从JWT Token或Session中获取，而不是从请求头
2. **权限验证**：确保用户只能查看和操作自己有权限的任务
3. **消息通知**：可以考虑添加消息通知功能，当有新消息时通知用户
4. **数据清理**：定期清理过期的已读记录，避免数据表过大

